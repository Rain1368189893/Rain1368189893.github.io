<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>My New Post | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JSON-RPC 2.0 规范学习以及前端接口封装JSON-RPC 2.0 规范学习
1 Json-rpc 2.0与传统json的后台接口不同的地方

最明显的不同体现在接口的调用上，传统的方法，一般是后端暴露接口给前端，前端进行接口联调；Json-rpc 2.0，在接口的调用上，实际上是调用了后台地址上的一个method方法，由method方法，再去映射到后端服务器的对应逻辑上。
example">
<meta property="og:type" content="article">
<meta property="og:title" content="My New Post">
<meta property="og:url" content="Rain1368189893.github.io/2016/08/16/My-New-Post/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JSON-RPC 2.0 规范学习以及前端接口封装JSON-RPC 2.0 规范学习
1 Json-rpc 2.0与传统json的后台接口不同的地方

最明显的不同体现在接口的调用上，传统的方法，一般是后端暴露接口给前端，前端进行接口联调；Json-rpc 2.0，在接口的调用上，实际上是调用了后台地址上的一个method方法，由method方法，再去映射到后端服务器的对应逻辑上。
example">
<meta property="og:image" content="http://i4.piimg.com/567571/ff156c44b7c37eb5.png">
<meta property="og:updated_time" content="2016-08-16T02:16:17.140Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My New Post">
<meta name="twitter:description" content="JSON-RPC 2.0 规范学习以及前端接口封装JSON-RPC 2.0 规范学习
1 Json-rpc 2.0与传统json的后台接口不同的地方

最明显的不同体现在接口的调用上，传统的方法，一般是后端暴露接口给前端，前端进行接口联调；Json-rpc 2.0，在接口的调用上，实际上是调用了后台地址上的一个method方法，由method方法，再去映射到后端服务器的对应逻辑上。
example">
<meta name="twitter:image" content="http://i4.piimg.com/567571/ff156c44b7c37eb5.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="Rain1368189893.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-My-New-Post" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/16/My-New-Post/" class="article-date">
  <time datetime="2016-08-16T02:13:01.000Z" itemprop="datePublished">2016-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      My New Post
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JSON-RPC-2-0-规范学习以及前端接口封装"><a href="#JSON-RPC-2-0-规范学习以及前端接口封装" class="headerlink" title="JSON-RPC 2.0 规范学习以及前端接口封装"></a>JSON-RPC 2.0 规范学习以及前端接口封装</h2><h3 id="JSON-RPC-2-0-规范学习"><a href="#JSON-RPC-2-0-规范学习" class="headerlink" title="JSON-RPC 2.0 规范学习"></a>JSON-RPC 2.0 规范学习</h3><ul>
<li><p>1 Json-rpc 2.0与传统json的后台接口不同的地方</p>
<ul>
<li>最明显的不同体现在接口的调用上，传统的方法，一般是后端暴露接口给前端，前端进行接口联调；Json-rpc 2.0，在接口的调用上，实际上是调用了后台地址上的一个method方法，由method方法，再去映射到后端服务器的对应逻辑上。</li>
<li><strong>example</strong>  <pre>
  {
 "jsonrpc" : "2.0",
 <strong>"method" : "subtract",</strong>
 "params" : {
     "subtrahend" : 23,
     "minuend" : 42
 },
 "id" : 3
  }
 </pre>
</li>
</ul>
</li>
<li><p>2 请求对象</p>
<pre><code>- 发送一个请求对象至服务端代表一个rpc调用，一个请求对象包含下列成员：
- **jsonrpc**
    &lt;pre&gt;指定JSON-RPC协议版本的字符串，必须准确写为“2.0”&lt;/pre&gt;
</code></pre><ul>
<li><strong>method</strong><pre><code>&lt;pre&gt;包含所要调用方法名称的字符串，以rpc开头的方法名，用英文句号（U+002E or ASCII 46）
</code></pre>  连接的为预留给rpc内部的方法名及扩展名，且不能在其他地方使用。</li>
<li><strong>params</strong><pre><code>&lt;pre&gt;调用方法所需要的结构化参数值，该成员参数可以被省略。&lt;/pre&gt;
</code></pre></li>
<li><p><strong>id</strong></p>
<pre><code>&lt;pre&gt;已建立客户端的唯一标识id，值必须包含一个字符串、数值或NULL空值。
</code></pre><p>  如果不包含该成员则被认定为是一个通知。该值一般不为NULL[1]，若为数值则不应该包含小数[2]</p>
</li>
<li><pre>[1]在请求对象中不建议使用NULL作为id值，因为该规范将使用空值认定为未知id的请求。
另外，由于JSON-RPC 1.0 的通知使用了空值，这可能引起处理上的混淆。
[2]使用小数是不确定性的，因为许多十进制小数不能精准的表达为二进制小数。</pre>
</li>
</ul>
</li>
<li><p>3 响应对象</p>
<ul>
<li>当发起一个rpc调用时，除通知外都必须回复响应。响应表示为一个json对象，使用以下成员：</li>
<li><strong>jsonrpc</strong>  <pre>指定JSON-RPC协议版本的字符串，必须准确写为“2.0”</pre></li>
<li><strong>result</strong>  <pre>该成员在成功时必须包含。</pre>
  <pre>当调用方法引起错误时必须不包含该成员。</pre>
  <pre>服务端中的被调用方法决定了该成员的值。</pre></li>
<li><strong>error</strong>  <pre>该成员在失败是必须包含。</pre>
  <pre>当没有引起错误的时必须不包含该成员。</pre>
  <pre>该成员参数值必须为5.1中定义的对象。</pre></li>
<li><strong>id</strong>  <pre>该成员必须包含。。</pre>
  <pre>该成员值必须于请求对象中的id成员值一致。</pre>
  <pre>若在检查请求对象id时错误（例如参数错误或无效请求），则该值必须为空值。</pre>
</li>
</ul>
</li>
<li><p>4 错误对象</p>
<ul>
<li>当一个rpc调用遇到错误时，返回的响应对象必须包含错误成员参数，并且为带有下列成员参数的对象</li>
<li><strong>code</strong></li>
<li><pre>使用数值表示该异常的错误类型。
  必须为整数。
</pre></li>
<li><strong>message</strong></li>
<li><pre>对该错误的简单描述字符串。
  该描述应尽量限定在简短的一句话。
</pre></li>
<li><strong>data</strong></li>
<li><pre>包含关于错误附加信息的基本类型或结构化类型。该成员可忽略。<br>  该成员值由服务端定义（例如详细的错误信息，嵌套的错误等）。<br></pre><br><img src="http://i4.piimg.com/567571/ff156c44b7c37eb5.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="前端接口封装"><a href="#前端接口封装" class="headerlink" title="前端接口封装"></a>前端接口封装</h3><pre><code>.service(&apos;dataService&apos;, [&apos;$http&apos;,&apos;$q&apos;,&apos;showMsgService&apos;,function ($http, $q, showMsgService) {
//    post方法
        this.postJsonData = function (parameters) {
            var deferred = $q.defer();

            parameters = {
                &quot;jsonrpc&quot; : &quot;2.0&quot;,
                 parameters
            };

            $http({
                method:&apos;POST&apos;,
                url: serverUrl,      //字符串，请求的目标
                data: parameters,    //在发送post请求时使用，作为消息体发送到服务器
                headers: {&apos;Content-Type&apos;:&apos;application/raw&apos;},    //一个列表，每个元素都是一个函数，返回http头
                transformRequest: function (parameters) {       //数或者函数数组，用来对http请求的请求体和头信息进行转换，并返回转换后的结果。
                    var str = [];
                    for (var p in parameters)
                        str.push(encodeURIComponent(p) + &quot;=&quot; + encodeURIComponent(parameters[p]));
                    return str.join(&quot;&amp;&quot;);
                }

            }).success(function (data, status, headers, config) {
                if (data.result != 200) {
                    showMsgService.showMsg(data.msg);
                    deferred.reject(data);
                } else {
                    deferred.resolve(data);
                }
            }).error(function (data, status, headers, config) {
                if(status == 400) {
                    showMsgService.showMsg(&apos;请求参数错误！&apos;);
                } else if(status == 405){
                    showMsgService.showMsg(&apos;无效的请求！&apos;);
                } else {
                    showMsgService.showMsg(&apos;网络连接异常，请检查网络后重试！&apos;);
                }
            });
            return deferred.promise;
        }    

//    get方法
        this.getJsonData = function (url, parameters) {
            var deferred = $q.defer();

            parameters = {
                &quot;jsonrpc&quot; : &quot;2.0&quot;,
                 parameters
            };

            $http.get(serverUrl, {params: parameters})
            .success(function (data, status, headers, config) {
                if (data.code != 200) {
                    showMsgService.showMsg(data.desc);
                    deferred.reject(data);
                } else {
                    deferred.resolve(data);
                }
            }).error(function (data, status, headers, config) {
                if(status == 400) {
                    showMsgService.showMsg(&apos;请求参数错误！&apos;);
                } else if(status == 405){
                    showMsgService.showMsg(&apos;无效的请求！&apos;);
                } else {
                    showMsgService.showMsg(&apos;网络连接异常，请检查网络后重试！&apos;);
                }
            });
            return deferred.promise;
        };

    }])
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="Rain1368189893.github.io/2016/08/16/My-New-Post/" data-id="cis5zgemv0001e8cy02jxi3nf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/08/16/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/16/My-New-Post/">My New Post</a>
          </li>
        
          <li>
            <a href="/2016/08/16/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Rain<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>